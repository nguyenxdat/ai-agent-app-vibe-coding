# WebSocket Protocol: AI Chat Realtime Communication

**Version**: 1.0.0
**Date**: 2025-11-04

## Overview

WebSocket protocol cho realtime bidirectional communication giữa Frontend client và A2A server. Được sử dụng chủ yếu cho chat messaging để đạt low-latency updates.

## Connection

### Endpoint

```
ws://localhost:8000/ws/chat/{sessionId}
wss://api.aichat.example.com/ws/chat/{sessionId}
```

### Authentication

Query parameters:
```
?token={auth_token}
```

Example:
```javascript
const ws = new WebSocket(
  `wss://api.aichat.example.com/ws/chat/${sessionId}?token=${authToken}`
)
```

### Connection Lifecycle

```
Client                                  Server
  |                                       |
  |---- WebSocket Handshake ------------>|
  |<--- 101 Switching Protocols ---------|
  |                                       |
  |<--- {"type": "connection_ack"} ------|
  |                                       |
  |---- {"type": "ping"} ---------------->|
  |<--- {"type": "pong"} -----------------|
  |                                       |
  |---- {"type": "message"} ------------->|
  |<--- {"type": "message"} --------------|
  |<--- {"type": "typing"} ---------------|
  |                                       |
  |---- Close Frame --------------------->|
  |<--- {"type": "disconnect"} -----------|
```

## Message Types

### 1. Connection Acknowledgment

**Direction**: Server → Client

**Sent**: Ngay sau khi WebSocket connection established

```json
{
  "type": "connection_ack",
  "sessionId": "660e8400-e29b-41d4-a716-446655440001",
  "timestamp": "2025-11-04T10:30:00Z",
  "serverVersion": "1.0.0"
}
```

---

### 2. Ping/Pong (Heartbeat)

**Direction**: Bidirectional

**Purpose**: Keep connection alive và detect disconnections

**Client → Server (Ping)**:
```json
{
  "type": "ping",
  "timestamp": "2025-11-04T10:30:15Z"
}
```

**Server → Client (Pong)**:
```json
{
  "type": "pong",
  "timestamp": "2025-11-04T10:30:15Z"
}
```

**Frequency**: Mỗi 30 giây, timeout sau 60 giây không nhận pong

---

### 3. User Message

**Direction**: Client → Server

**Purpose**: User gửi tin nhắn đến agent

```json
{
  "type": "message",
  "messageId": "550e8400-e29b-41d4-a716-446655440000",
  "content": "Thời tiết hôm nay thế nào?",
  "format": "plain",
  "timestamp": "2025-11-04T10:30:20Z",
  "metadata": {}
}
```

**Fields**:
- `type` (required): "message"
- `messageId` (required): UUID v4 generated by client
- `content` (required): Message content (max 10,000 chars)
- `format` (required): "plain", "markdown", hoặc "code"
- `timestamp` (required): ISO 8601 datetime
- `metadata` (optional): Additional data (language for code, etc.)

---

### 4. Agent Response

**Direction**: Server → Client

**Purpose**: Agent trả lời user message

```json
{
  "type": "message",
  "messageId": "551e8400-e29b-41d4-a716-446655440001",
  "replyTo": "550e8400-e29b-41d4-a716-446655440000",
  "sender": "agent",
  "content": "Hôm nay Hà Nội trời nắng, nhiệt độ 28°C.",
  "format": "plain",
  "timestamp": "2025-11-04T10:30:25Z",
  "metadata": {}
}
```

**Fields**:
- `type` (required): "message"
- `messageId` (required): UUID v4 for agent message
- `replyTo` (required): messageId of user message being replied to
- `sender` (required): "agent"
- `content` (required): Response content
- `format` (required): "plain", "markdown", hoặc "code"
- `timestamp` (required): ISO 8601 datetime
- `metadata` (optional): Additional data

---

### 5. Typing Indicator

**Direction**: Server → Client

**Purpose**: Hiển thị agent đang typing

```json
{
  "type": "typing",
  "isTyping": true,
  "timestamp": "2025-11-04T10:30:21Z"
}
```

**Fields**:
- `type` (required): "typing"
- `isTyping` (required): true khi agent bắt đầu typing, false khi stop
- `timestamp` (required): ISO 8601 datetime

**Behavior**:
- Server gửi `isTyping: true` khi agent bắt đầu process message
- Server gửi `isTyping: false` khi agent gửi response hoặc error

---

### 6. Streaming Response (Optional)

**Direction**: Server → Client

**Purpose**: Stream agent response từng phần (cho long responses)

```json
{
  "type": "stream",
  "messageId": "551e8400-e29b-41d4-a716-446655440001",
  "replyTo": "550e8400-e29b-41d4-a716-446655440000",
  "chunk": "Hôm nay Hà Nội",
  "isComplete": false,
  "timestamp": "2025-11-04T10:30:23Z"
}
```

**Fields**:
- `type` (required): "stream"
- `messageId` (required): UUID v4, same cho tất cả chunks của message
- `replyTo` (required): messageId of user message
- `chunk` (required): Content chunk
- `isComplete` (required): true cho chunk cuối cùng
- `timestamp` (required): ISO 8601 datetime

**Final chunk**:
```json
{
  "type": "stream",
  "messageId": "551e8400-e29b-41d4-a716-446655440001",
  "replyTo": "550e8400-e29b-41d4-a716-446655440000",
  "chunk": " 28°C.",
  "isComplete": true,
  "timestamp": "2025-11-04T10:30:25Z",
  "format": "plain",
  "metadata": {}
}
```

---

### 7. Error

**Direction**: Server → Client

**Purpose**: Notify client về errors

```json
{
  "type": "error",
  "code": "AGENT_UNAVAILABLE",
  "message": "Agent không phản hồi, vui lòng thử lại sau",
  "relatedMessageId": "550e8400-e29b-41d4-a716-446655440000",
  "timestamp": "2025-11-04T10:30:25Z",
  "retryable": true
}
```

**Error Codes**:
- `AGENT_UNAVAILABLE`: Agent endpoint không available
- `AGENT_TIMEOUT`: Agent không response trong timeout period
- `INVALID_MESSAGE`: Message format không hợp lệ
- `RATE_LIMIT_EXCEEDED`: Too many messages trong short time
- `SESSION_NOT_FOUND`: SessionId không tồn tại
- `AUTHENTICATION_FAILED`: Auth token invalid hoặc expired
- `INTERNAL_ERROR`: Server internal error

**Fields**:
- `type` (required): "error"
- `code` (required): Error code (see above)
- `message` (required): Human-readable error message
- `relatedMessageId` (optional): messageId liên quan đến error
- `timestamp` (required): ISO 8601 datetime
- `retryable` (required): true nếu client có thể retry

---

### 8. Disconnect

**Direction**: Server → Client

**Purpose**: Notify client trước khi close connection

```json
{
  "type": "disconnect",
  "reason": "Session expired",
  "code": 1000,
  "timestamp": "2025-11-04T11:30:00Z"
}
```

**Disconnect Codes** (WebSocket close codes):
- `1000`: Normal closure
- `1001`: Going away (server shutdown)
- `1008`: Policy violation (auth failed, etc.)
- `1011`: Internal error

---

## Client Implementation Example

```typescript
class ChatWebSocket {
  private ws: WebSocket | null = null
  private pingInterval: NodeJS.Timeout | null = null
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5

  connect(sessionId: string, authToken: string) {
    const url = `wss://api.aichat.example.com/ws/chat/${sessionId}?token=${authToken}`
    this.ws = new WebSocket(url)

    this.ws.onopen = () => {
      console.log('WebSocket connected')
      this.reconnectAttempts = 0
      this.startPing()
    }

    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data)
      this.handleMessage(message)
    }

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error)
    }

    this.ws.onclose = (event) => {
      console.log('WebSocket closed:', event.code, event.reason)
      this.stopPing()
      this.handleReconnect()
    }
  }

  private handleMessage(message: any) {
    switch (message.type) {
      case 'connection_ack':
        console.log('Connection acknowledged')
        break
      case 'message':
        this.onMessageReceived(message)
        break
      case 'typing':
        this.onTypingIndicator(message.isTyping)
        break
      case 'error':
        this.onError(message)
        break
      case 'pong':
        // Heartbeat received
        break
      default:
        console.warn('Unknown message type:', message.type)
    }
  }

  sendMessage(content: string, format: 'plain' | 'markdown' | 'code' = 'plain') {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      throw new Error('WebSocket not connected')
    }

    const message = {
      type: 'message',
      messageId: crypto.randomUUID(),
      content,
      format,
      timestamp: new Date().toISOString(),
      metadata: {}
    }

    this.ws.send(JSON.stringify(message))
  }

  private startPing() {
    this.pingInterval = setInterval(() => {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify({
          type: 'ping',
          timestamp: new Date().toISOString()
        }))
      }
    }, 30000) // Every 30 seconds
  }

  private stopPing() {
    if (this.pingInterval) {
      clearInterval(this.pingInterval)
      this.pingInterval = null
    }
  }

  private handleReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++
      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000)
      console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`)
      setTimeout(() => this.connect(sessionId, authToken), delay)
    } else {
      console.error('Max reconnect attempts reached')
      this.onMaxReconnectReached()
    }
  }

  disconnect() {
    if (this.ws) {
      this.stopPing()
      this.ws.close(1000, 'Client disconnect')
      this.ws = null
    }
  }

  // Callback functions (to be overridden)
  onMessageReceived(message: any) {}
  onTypingIndicator(isTyping: boolean) {}
  onError(error: any) {}
  onMaxReconnectReached() {}
}
```

---

## Server Implementation Notes

### Connection Management

```python
from fastapi import WebSocket, WebSocketDisconnect
from typing import Dict

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}

    async def connect(self, session_id: str, websocket: WebSocket):
        await websocket.accept()
        self.active_connections[session_id] = websocket
        await self.send_json(session_id, {
            "type": "connection_ack",
            "sessionId": session_id,
            "timestamp": datetime.now().isoformat(),
            "serverVersion": "1.0.0"
        })

    def disconnect(self, session_id: str):
        if session_id in self.active_connections:
            del self.active_connections[session_id]

    async def send_json(self, session_id: str, data: dict):
        if session_id in self.active_connections:
            await self.active_connections[session_id].send_json(data)

    async def broadcast_typing(self, session_id: str, is_typing: bool):
        await self.send_json(session_id, {
            "type": "typing",
            "isTyping": is_typing,
            "timestamp": datetime.now().isoformat()
        })

manager = ConnectionManager()
```

---

## Security Considerations

1. **Authentication**: Validate token trong query parameters hoặc initial message
2. **Rate Limiting**: Limit số messages per second per connection
3. **Message Size**: Enforce max message size (10KB recommended)
4. **Connection Timeout**: Close idle connections sau 5 minutes
5. **Origin Validation**: Validate Origin header cho CORS protection

---

## Testing

### Manual Testing với wscat

```bash
# Install wscat
npm install -g wscat

# Connect
wscat -c "ws://localhost:8000/ws/chat/660e8400-e29b-41d4-a716-446655440001?token=test_token"

# Send message
{"type":"message","messageId":"550e8400-e29b-41d4-a716-446655440000","content":"Hello","format":"plain","timestamp":"2025-11-04T10:30:20Z"}
```

### Automated Testing

Use Playwright hoặc Puppeteer cho WebSocket E2E tests:

```javascript
test('WebSocket chat flow', async () => {
  const ws = await page.evaluateHandle(() => {
    return new WebSocket('ws://localhost:8000/ws/chat/test-session?token=test')
  })

  await page.waitForFunction(
    (ws) => ws.readyState === WebSocket.OPEN,
    ws
  )

  // Send message và verify response
  // ...
})
```

---

## Summary

WebSocket protocol này cung cấp:
- ✅ Bidirectional realtime communication
- ✅ Low-latency message delivery
- ✅ Typing indicators cho better UX
- ✅ Streaming support cho long responses
- ✅ Automatic reconnection với exponential backoff
- ✅ Heartbeat mechanism cho connection health
- ✅ Comprehensive error handling
